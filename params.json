{"name":"RFTM","tagline":"","body":"The RFTM is a testing methodology that can be applied to all Radio Frequency (wireless) technologies that are encountered on client engagements or during research for which conventional transceivers are not available. This is methodology is therefore, most appropriate for the assessment of proprietary RF protocols.\r\n\r\nThroughout this methodology, we'll use various real-world examples, including the [Io-homecontrol](https://wiki.pentest.ngs/index.php/Io-homecontrol) protocol.\r\n\r\nSignals basics\r\n==============\r\n\r\n![](Signals basics1.png \"fig:Signals basics1.png\") Signals are electromagnetic waves measured in Hz (cycles per second)\r\n\r\n![](Signals basics2.png \"fig:Signals basics2.png\") To transmit useful information we need to “modulate” a carrier signal with the information\r\n\r\n![](Signals basics3.png \"fig:Signals basics3.png\") Frequency Modulation changes the frequency of the carrier proportionally to the information you wish to transmit\r\n\r\nModulation schemes\r\n==================\r\n\r\nFrequency modulation\r\n--------------------\r\n\r\nAn example of a varying input signal modulating a carrier wave by proportionally changing it's frequency is shown above. If digital information needs to be modulated then FSK is used:\r\n\r\nFSK\r\n\r\n![](FSK.png \"FSK.png\")\r\n\r\nAmplitude modulation\r\n--------------------\r\n\r\nAnother modulation scheme is Amplitude Modulation, where the amplitude (or volume) of the carrier is modified proportionally to the signal. One disadvantage of AM is that the receiver amplifies and detects noise and electromagnetic interference in equal proportion to the signal, which is why AM radio signals are not as clear as FM radio signals.\r\n\r\nAM\r\n\r\n![](AM.jpg \"AM.jpg\")\r\n\r\nThe digital equivalent of AM is ASK\r\n\r\nASK\r\n\r\n![](ASK.png \"ASK.png\")\r\n\r\nPhase modulation\r\n----------------\r\n\r\nThe third major modulation scheme is Phase Modulation where the phase of the carrier is modified proportionally by the input signal. PM looks very similar to FM, but it's much clearer what is going on when you look at the PSK signal below.\r\n\r\nPM\r\n\r\n![](PM.jpg \"PM.jpg\")\r\n\r\nThe digital equivalent of PM is PSK\r\n\r\nPSK\r\n\r\n![](PSK.png \"PSK.png\")\r\n\r\nMore complex modulation schemes\r\n-------------------------------\r\n\r\nIn order to smooth the transitions in digital modulation there are \"Gaussian\" variants e.g. GFSK (Gaussian Frequency Shift Keying). This reduces the bandwidth of the signal channel by applying a [Gaussian filter](http://en.wikipedia.org/wiki/Gaussian_filter) prior to modulation.\r\n\r\nIn previous examples there have only been two symbols (one representing a \"0\" and the other representing a \"1\"). To increase the data rate, multiple symbols are created at different amplitudes and phases e.g with 16QAM. Below is a phase diagram with the phase angle represented as the 360 degrees around the origin (centre of the diagram) and the amplitude represented as the vector distance from the origin. Each symbol can now represent four bits:\r\n\r\n![](16QAM.png \"16QAM.png\")\r\n\r\nTODO: Add much more about modulation here\r\n\r\nInformation sources\r\n===================\r\n\r\nBefore you can receive any signals from your target system you'll need various important pieces of information.\r\n\r\nInformation you need to discover\r\n--------------------------------\r\n\r\n-   Carrier frequencies for transmission channels\r\n\r\n<!-- -->\r\n\r\n-   Transmission power\r\n\r\n<!-- -->\r\n\r\n-   Modulation scheme details\r\n\r\n<!-- -->\r\n\r\n-   Data rates and symbol rates\r\n\r\n<!-- -->\r\n\r\n-   Other considerations e.g. frequency hopping / spread spectrum etc.\r\n\r\n<!-- -->\r\n\r\n-   Data protocol information\r\n\r\nProduct data sheets\r\n-------------------\r\n\r\nData sheets can provide a wealth of useful information - below is an example of a datasheet for the transceiver chip within an io-homecontrol device: ![](Iohome datasheet.png \"fig:Iohome datasheet.png\")\r\n\r\nAs can be seen in the example above, there are a number of very useful pieces of information:\r\n\r\nData protocol information - CRC, preamble, start byte\r\n\r\nThe number of channels and what their operating frequencies are:\r\n\r\n-   Channel 1: 868.25MHz\r\n\r\n<!-- -->\r\n\r\n-   Channel 2: 868.95MHz\r\n\r\n<!-- -->\r\n\r\n-   Channel 3: 869.85MHz\r\n\r\nThe data rate and modulation scheme - 38.4kbps FSK, 20 KHz deviation\r\n\r\nFCC database\r\n------------\r\n\r\nThe [Federal Communication Commission](http://www.fcc.gov/) (FCC) is responsible for regulating RF transmissions in the US. Any piece of equipment that is sold in the US must submit their product for testing by the FCC to ensure it complies with the regulations and once it has been certified a report is added to their [publicly searchable database](http://transition.fcc.gov/oet/ea/fccid/). In addition to the technical specifications of the product, each report contains high resolution photographs of both the outside and inside, including all circuit boards.\r\n\r\nReceiving data\r\n==============\r\n\r\nHistorically, in order to receive RF signals you would require expensive hardware, which may only work for a small range of frequencies. With the popularization of Software Defined Radio, cheap, configurable radio solutions can now easily be developed.\r\n\r\nHardware: Software Defined Radio\r\n--------------------------------\r\n\r\nIn order to receive and signals you'll need an [SDR](https://wiki.pentest.ngs/index.php/Software-Defined_Radio). Within NCC Group we have at least one of each of the following SDRs:\r\n\r\n-   HackRF One\r\n\r\n<!-- -->\r\n\r\n-   BladeRF\r\n\r\n<!-- -->\r\n\r\n-   RTL-SDR\r\n\r\n<!-- -->\r\n\r\n-   FUNcube Pro+\r\n\r\nHardware: Antennas\r\n------------------\r\n\r\nAntennas are generally designed to work within specific frequency bands, as their size generally relates to the wavelength of signals and hence determines the frequencies at which they can operate (as a general rule, the larger the antenna, the lower the frequency band on which it operates as [wavelength is inversely proportional to frequency](http://en.wikipedia.org/wiki/Wavelength#Sinusoidal_waves)).\r\n\r\nBelow are a few examples of antenna types (there are many available!):\r\n\r\nOmni-directional, limited to narrow frequency band - this is the type you are most likely to use with your SDR:\r\n\r\n![](Omni antenna.png \"Omni antenna.png\")\r\n\r\nOmni-directional, wideband antenna - for covering a much larger range of frequencies when scanning a wide RF environment:\r\n\r\n![](Wideband antenna.png \"Wideband antenna.png\")\r\n\r\nDirectional \"Yagi\" antenna - for focusing the beam in a very specific direction (used for terrestrial TV reception):\r\n\r\n![](433 yagi.png \"433 yagi.png\")\r\n\r\nTODO: Add some antenna theory here to explain how they work\r\n\r\nHardware: Connectors\r\n--------------------\r\n\r\nBelow are some of the most common connectors you will encounter in the world of RF: (a more exhaustive list is available [here](http://telcoantennas.com.au/site/guide-antenna-cables-connectors))\r\n\r\nSMA - This is the most common connector you will encounter when using SDR (good for up to 18GHz)\r\n\r\n![](Sma female.jpg \"fig:Sma female.jpg\")![](Sma male.jpg \"fig:Sma male.jpg\")\r\n\r\nRP-SMA - These are often used on WiFi routers - do not confuse with SMA, as **they are not compatible with SMA!**\r\n\r\n![](Rp-sma female.jpg \"fig:Rp-sma female.jpg\")![](Rp-sma male.jpg \"fig:Rp-sma male.jpg\")\r\n\r\nMCX - These are used on the RTL-SDR and some older WiFi PC cards\r\n\r\n![](Mcx female2.jpg \"fig:Mcx female2.jpg\")![](Mcx male.jpg \"fig:Mcx male.jpg\")\r\n\r\nBNC - Often used for lower frequency antennas (only good for up to 4GHz)\r\n\r\n![](Bnc-female.jpg \"fig:Bnc-female.jpg\")![](Bnc-male.jpg \"fig:Bnc-male.jpg\")\r\n\r\nN-type - used for more industrial purposes e.g. radar, mobile base stations\r\n\r\n![](N-type female.jpg \"fig:N-type female.jpg\")![](N-type male.jpg \"fig:N-type male.jpg\")\r\n\r\nHardware: Amplifiers\r\n--------------------\r\n\r\nSometimes the signal you are trying to receive is very low level and therefore, an amplifier is required. Below is an example of a typical [Low Noise Amplifier](http://en.wikipedia.org/wiki/Low-noise_amplifier) that has been successfully used with an SDR:\r\n\r\n![](Low noise amp2.png \"Low noise amp2.png\")\r\n\r\nTODO: Add more info about amplifiers and explain Signal to Noise ratio\r\n\r\nSoftware: GNU Radio\r\n-------------------\r\n\r\n[GNU Radio](http://gnuradio.org/redmine/projects/gnuradio/wiki) is a free and open-source software development toolkit that provides signal processing blocks to implement software radios. It can be used with readily-available low-cost external RF hardware to create software-defined radios, or without hardware in a simulation-like environment. It is widely used in hobbyist, academic and commercial environments to support both wireless communications research and real-world radio systems.\r\n\r\nThe [GNU Radio Live DVD](http://gnuradio.org/redmine/projects/gnuradio/wiki/GNURadioLiveDVD) can be downloaded here (it supports all the major SDRs)\r\n\r\nDeveloping a digital (FSK) receiver step-by-step\r\n------------------------------------------------\r\n\r\n### Configure the GNU Radio environment\r\n\r\nWhen you first start GNU Radio Companion, you are presented with an Options block and a Variable block. The Options block allows you to enter parameters such as the Title, Author, Description and also allows you to decide if the GUI elements will use the WX or QT environments (WX is the default).\r\n\r\n**Hint: When using GNU Radio Companion if you cannot find the block you are looking for in the right-hand pane, click on the magnifying glass in the menu bar and this will enable you to do a text search**\r\n\r\n![](Grc top block.png \"Grc top block.png\")\r\n\r\nThe sample rate must be at least twice the maximum frequency (of the modulated data - not the carrier signal), but the higher the sample rate, the clearer the signal will be, which initially will help aid signal identification. The default is 32,000, but I would recommend at least 4,000,000 (4e6 is an easier way to write this, as you don't need to count the zeros!)\r\n\r\n![](Grc samp rate.png \"Grc samp rate.png\")\r\n\r\n### Configure the receiver\r\n\r\nDepending on which SDR you have will depend on which options you set here. All of the main receivers can be controlled using the \"osmocom Source\". The \"Device Arguments\" settings for different SDRs can be found [here](http://sdr.osmocom.org/trac/wiki/GrOsmoSDR#Devicespecification). However, if you are using an RTL-SDR, you can also just use the \"RTL-SDR Source\".\r\n\r\n![](Grc osmocom source.png \"Grc osmocom source.png\")\r\n\r\nThe sample rate will already be pre-populated with the \"samp\\_rate\" variable. Set \"Ch0: Frequency\" to be \"centre\\_freq\" and then create a new variable called \"centre\\_freq\" with a value near your target carrier frequency.\r\n\r\n![](Grc centre freq.png \"Grc centre freq.png\")\r\n\r\nAlthough you may need to increase the gains at a later stage if the signal is too weak, initially, use the following settings:\r\n\r\n-   Ch0: RF Gain - 0dB\r\n\r\n<!-- -->\r\n\r\n-   Ch0: IF Gain - 10dB\r\n\r\n<!-- -->\r\n\r\n-   Ch0: BB Gain - 10dB\r\n\r\nLeave everything else at the defaults.\r\n\r\nSelect a \"WX GUI FFT Sink\" and connect it to the output of the receiver by clicking on the receiver output and then clicking on the \"WX GUI FFT Sink\" input - an arrow will link them together (if you want to unlink two blocks, click on the link and drag - it will disappear).\r\n\r\n**Note: By default the inputs and outputs are blue on these blocks, this denotes the type (blue = complex data, orange = float etc.) If the colours do not match on the connecters you are trying to connect together you will get a type-mismatch error and the arrow will go red.**\r\n\r\nIn \"WX GUI FFT Sink\" set \"Peak Hold\" to \"On\", this will ensure that any signals that appear will stay displayed, even if they are transient:\r\n\r\n![](Grc wx gui fft sink.png \"Grc wx gui fft sink.png\")\r\n\r\nYou are now ready to start the receiver - click on the gears icon in the menu bar and the flow-graph will start. The FFT sink displays 4MHz of bandwidth (your sample rate is 4 million and therefore the receiver is simultaneously sampling 4 million signals every second). The display is showing you everything that is being received in the frequency domain, so every peak is a different signal. If you were to tune through the FM broadcast band (87.5 – 108.0 MHz) each peak would be a different radio broadcast signal. FFT is [Fast Fourier Transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform) - feel free to read all about it if you enjoy your maths! But understanding how it works is not required. Below is the output I saw when I started my receiver using the centre frequency 867.3MHz, which is in the [ISM band](http://en.wikipedia.org/wiki/ISM_band) that's generally used for devices that form the Internet of Things:\r\n\r\n![](Grc received baseband.png \"Grc received baseband.png\")\r\n\r\nI have no idea what this signal is, but thought it would be a great opportunity to test out my methodology against, so the remainder of this receiver development example is based on this signal. Looking at the frequency, it is around 1Mhz higher than my centre frequency, so about 868.3MHz.\r\n\r\nThe flow-graph can be stopped by closing the FFT window.\r\n\r\n### Visualising the signal\r\n\r\nSo far we know that there is a signal (which happens to be repeating periodically) at around 868.3MHz, but we have no idea about what that signal is. The next stage is to save it to a file so we can do some post-processing. Add a \"File Sink\" and connect it to the output of the \"osmocom Source\". Set the filename to something sensible - I always include the sample rate within the filename, so use something like \"4M\\_received\\_baseband\". Restart the flow-graph by clicking on the gears icon and record enough data so that it includes the signal of interest.\r\n\r\n**Note: SDRs generate very large amounts of data - a recording lasting only a few seconds can result in many tens of megabytes of data, so experiment first!**\r\n\r\nNow we have a recording we can visualize the signal a bit better using a tool called [Baudline](http://www.baudline.com/), which is an excellent tool for RF visualization that can be very helpful for signals identification. Unfortunately a bug in Baudline means that it does not like file sizes greater than 50Mb. So, before you can load it into Baudline you'll need to split your file into 50Mb chunks:\r\n\r\n\\<pre\\> split -b50m 4M\\_received\\_baseband part \\</pre\\>\r\n\r\nThis should result in a series of files called \"parta, partb, partc etc.\"\r\n\r\nStart up Baudline:\r\n\r\n![](Baudline default.png \"Baudline default.png\")\r\n\r\nRight-click to open the main menu -\\> input -\\> open file. Make sure you select your \"partx\" file rather than \"4M\\_received\\_baseband\".\r\n\r\nA window will appear with a range of options; select the following:\r\n\r\n-   Sample rate: \"Custom - 4000000\"\r\n\r\n<!-- -->\r\n\r\n-   Channels: 2\r\n\r\n<!-- -->\r\n\r\n-   Tick \"quadrature\" and \"flip complex\"\r\n\r\n<!-- -->\r\n\r\n-   Decode Format: 32 bit float\r\n\r\n![](Baudline load file.png \"Baudline load file.png\")\r\n\r\nThen click \"Open\"\r\n\r\nThe file will be displayed graphically with time vertically and frequencies displayed horizontally.\r\n\r\n![](Baudline signal.png \"Baudline signal.png\")\r\n\r\nYou may need to play with the colours to make the signal clearer (main menu -\\> input -\\> colour aperture)\r\n\r\nIf you look carefully at the output, you can see a squiggly yellow line - that is the signal! You can zoom in and out of the time domain using Alt-up arrow and Alt-down arrow. If you want more detail in the frequency domain you need to change the FFT \"bin size\" (main menu -\\> process -\\> transform size).\r\n\r\n### Signal identification\r\n\r\nIf you zoom in it looks like this:\r\n\r\n![](Baudline signal zoomed.png \"Baudline signal zoomed.png\")\r\n\r\nAs the line is moving from left to right and the horizontal axis is frequency, this looks very much like Frequency Shift Keying. Also, when data is sent over RF it always starts with something called a \"preamble\", which is used to help denote the start of some data and also synchronise the receiver with the data. Preambles are normally 101010101010...\r\n\r\n### Centering the signal\r\n\r\nGoing back to GNU Radio companion, we now need do some more processing to make sure the signal is centered. First, replace the receiver with a \"File Source\" block that will replay the \"partx\" file that contains the signal. Also, set the file repeat to \"Yes\". Next, add a \"Throttle\" block after the \"File Source\", so that we don't overwhelm the CPU on the PC running GNU Radio Companion.\r\n\r\nAdd a \"Signal Source\" block with the Frequency set to \"-950e3\" (I said the signal looked like it was about 1MHz higher than the centre - it was actually 950KHz)\r\n\r\n![](Grc signal source.png \"Grc signal source.png\")\r\n\r\nAdd a \"Multiply\" block and connect the \"Throttle\" output and \"Signal Source\" output to the two \"Multiply\" inputs. Add the \"Multiply\" output to the \"WX GUI FFT Sink\" and your flow-graph should look like this:\r\n\r\n![](Grc multiply.png \"Grc multiply.png\")\r\n\r\nStart the flow-graph and the signal will now be centred:\r\n\r\n![](Grc fft centred.png \"Grc fft centred.png\")\r\n\r\n### Filtering\r\n\r\nWe now want to focus in on the signal of interest and filter out any other signals present in the baseband we have recorded. Add a \"Low Pass Filter\" block between the \"Multiply\" block output and the \"WX GUI FFT Sink\" input.\r\n\r\n-   Set \"Cutoff Freq\" to 150e3 - this is the maximum frequency (of the modulated signal) that we want to display\r\n\r\n<!-- -->\r\n\r\n-   Set \"Transition Width\" to 50e3 - this is the bandwidth over which the filter will act i.e. the smaller the number the more aggressive the filter.\r\n\r\nRestart the flow-graph and you should see something like this:\r\n\r\n![](Grc filtered signal.png \"Grc filtered signal.png\")\r\n\r\n### Demodulating\r\n\r\nWe are making the assumption that based on the output we observed in Baudline, the modulation scheme is FSK (to be precise, \"2-FSK\" or \"Binary FSK\" where the frequency is shifted one way for a \"0\" and the other for a \"1\"). Therefore, we need to add an FSK demodulator - there are many different modulators available within GNU Radio Companion, but the one we want is the \"Quadrature Demod\".\r\n\r\nAdd a \"Quadrature Demod\" and set the \"Gain\" to be 1.\r\n\r\nAdd a \"File Sink\" and set its input type to be \"float\" (orange coloured) and set the filename to be something like \"4M\\_filtered\\_demod\"\r\n\r\nConnect the output of the \"Low Pass Filter\" to the input of the \"Quadrature Demod\"\r\n\r\nConnect the output of the \"Quadrature Demod\" to the input of the \"File Sink\"\r\n\r\nIn \"File Source\" set \"Repeat to \"No\"\r\n\r\nYour flow-graph should now look like this:\r\n\r\n![](Grc demod save.png \"Grc demod save.png\")\r\n\r\nRun the flow-graph and it will produce a file that hopefully will contain demodulated data.\r\n\r\n### Visualising the data\r\n\r\nWe should now have a demodulated file that can be loaded into Baudline.\r\n\r\n**Note: Remember, if your \"4M\\_filtered\\_demod\" file is larger than 50Mb then you will need to split it into chunks again.**\r\n\r\nStart Baudline and load your demod file - use all the same parameters as before, but this time change \"Channels\" to 1 (it is no longer a complex baseband signal - it is a demodulated signal). Click \"Open\" and it should look something like this:\r\n\r\n![](Baudline demod1.png \"Baudline demod1.png\")\r\n\r\nEnsure that the separate \"Waveform\" window is open (main menu -\\> displays -\\> waveform)\r\n\r\nThe output in the \"Waveform\" window can be zoomed in or out vertically and horizontally using Alt + cursor keys. To move the signal up and down just use the cursor keys. The output should initially look something like this:\r\n\r\n![](Baudline waveform1.png \"Baudline waveform1.png\")\r\n\r\nAlthough it seems quite clear in the main Baudline window, you'll need to search for your demodulated signal :-)\r\n\r\nBy scrolling out horizontally, you should see lots of noise and then a section of no noise - this is your signal:\r\n\r\n![](Baudline waveform2.png \"Baudline waveform2.png\")\r\n\r\nUnfortunately, when you try and zoom in, the data is almost unrecognizable, because of the level of noise affecting it. If this is the case it means that you need to reduce the \"Cutoff Freq\" and \"Transition Width\" of your \"Low Pass Filter\". After some experimentation, some reasonable values were chosen:\r\n\r\n-   \"Cutoff Freq\" = 50e3\r\n\r\n<!-- -->\r\n\r\n-   \"Transition Width\" = 20e3\r\n\r\nNow when the signal was loaded in Baudline it looked like this:\r\n\r\n![](Baudline demod cleaner.png \"Baudline demod cleaner.png\")\r\n\r\nThese are the data bits represented by the original \"squiggly line\" we saw in Baudline when we looked at the complex baseband signal. It also confirms that the data was modulated using 2-FSK.\r\n\r\n### Further filtering and clock recovery\r\n\r\nAs we can see from the signal, it still looks very noisy, so we need to do some further, more accurate filtering and in order to do this we need to estimate the Baud rate (the number of symbols per second), but first we need to discuss how the data is represented. It looks like the peak represents a \"1\" and a trough for a \"0\", however it's not quite as simple as that; it is in fact encoded using something called \"Manchester encoding\". Manchester encoding is what is known as a [\"line code\"](http://en.wikipedia.org/wiki/Line_code) and ensures frequent voltage transitions, directly proportional to the clock rate, which helps clock recovery. What this actually means is that a \"0\" is represented by a transition to low and a \"1\" is represented by a transition to high.\r\n\r\n![](Manchester encoding.png \"Manchester encoding.png\")\r\n\r\nIf we look at the signal with respect to the scale, we can see that by choosing a peak, its just short of 2.5 bits (transition down, transition up, start of transition down) per millisecond, which if you know your standard Baud rates (they don't always conform to standard Baud rates!), it looks like 2400Baud (simple FSK data rates are usually very slow, as data packets are typically quite small)\r\n\r\n![](Baudline demod cleaner rate.png \"Baudline demod cleaner rate.png\")\r\n\r\nOk, now we think we have the Baud rate, we can accurately add a new \"Low Pass Filter\" in between the \"Quadrature Demod\" and the \"File Sink\". The settings should be as follows:\r\n\r\n-   Cutoff Freq = 2400 (the Baud rate)\r\n\r\n<!-- -->\r\n\r\n-   Transition Width = 1200 (half the Baud rate)\r\n\r\nAlso, you may have noticed that the flow-graph has been running very slowly since we started demodulating the data. Let's try and work out why:\r\n\r\nThe sample rate is currently 4,000,000 and the Baud rate is 2400, so if we divide 4,000,000 by 2400 we get the number of samples per symbol - 1666! That's why it's running slowly... we don't need anywhere near 1666 samples to represent each bit.\r\n\r\nIn the \"Low Pass Filter\" set \"FIR Type\" to \"Float-Float (Decimating)\" and set \"Decimation\" to 100. This will decimate the signal (reduce the sample rate) by a factor of 100\r\n\r\nNow re-run the flow-graph and load the resulting demodulated file into Baudline and the \"Waveform view\" should now look like this:\r\n\r\n**Note: When you load the file back into Baudline don't forget that the sample rate has been decimated by 100 and is now, therefore, 40,000 instead of 4,000,000**\r\n\r\n![](Baudline demod really clean.png \"Baudline demod really clean.png\")\r\n\r\nWe're not quite ready to recover the bits yet though, as the signal should be alternating about 0dBm (the centre line in the waveform view. It's actually up towards +90dBm, so it needs to be reduced.\r\n\r\nAdd a \"Add Const\" block in between the second \"Low Pass Filter\" and the \"File Sink\" and set the \"Constant\" value to be -0.055 (this value was determined through trial-and-error), to reduce the signal level down. The output should now look like this:\r\n\r\n![](Baudline final signal.png \"Baudline final signal.png\")\r\n\r\n### Data recovery\r\n\r\nNow we are ready to recover the digital data. First we need to perform clock recovery - add a \"Clock Recovery MM\" block and set the following values:\r\n\r\n-   \"Gain Omega\": 0.01\r\n\r\n<!-- -->\r\n\r\n-   \"Mu\": 0\r\n\r\n<!-- -->\r\n\r\n-   \"Gain Mu\": 0.1\r\n\r\n<!-- -->\r\n\r\n-   \"Omega Relative Limit\": 0.01\r\n\r\nIf you're interested in what these values mean then read [<http://ieeexplore.ieee.org/xpl/login.jsp?tp>=&arnumber=1093326&url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F26%2F23866%2F01093326.pdf%3Farnumber%3D1093326 Timing Recovery in Digital Synchronous Data Receivers] by Mueller and Muller.\r\n\r\nThe final value we need is \"Omega\" - this is the number of samples per symbol. We previously calculated this to be 1666 and so decimated the signal by a factor of 100 so \"Omega\" now needs to be set to 16.66 (1666 / 100).\r\n\r\nAdd a \"Binary Slicer\" to the output of the \"Clock Recovery MM\" block\r\n\r\nAdd a \"File Sink\" to the output of the \"Binary Slicer\" - you'll need to set the input type of the \"File Sink\" to \"Byte\" (pink coloured). Set the filename to be something like \"bitfile\"\r\n\r\nYour final flow-graph should look something like this:\r\n\r\n![](Fsk full flowgraph.png \"Fsk full flowgraph.png\")\r\n\r\nOpen up the \"bitfile\" file in a hex editor. Remember the preamble of \"0101010101...\"? If you count them, there are four bytes worth (32bits) so you need to search for the preamble in the \"bitfile\", but if you look carefully, you can see that each byte in the file represents one bit i.e a \"0\" bit is represented by the byte \"00\" and a \"1\" bit is represented by the byte \"01\", so to search for the preamble you need to search for: \"0001000100010001000100010001000100010001000100010001000100010001\". The result of the search is shown below, the rest of the data follows the preamble:\r\n\r\n![](Hex editor bits.png \"Hex editor bits.png\")\r\n\r\nYou have now successfully retrieved the data from an RF transmission!\r\n\r\nI still have no idea what this signal actually originates from - maybe one of my neighbours has an automatic garage door, or it could be a wireless central heating controller or some other IoT device.\r\n\r\n### Communicating with the receiver in real-time\r\n\r\nRather than using a file as a sink you can use a \"TCP Sink\" block, bind it to a socket and receive data from it via TCP\r\n\r\nDeveloping a digital (ASK) receiver step-by-step\r\n------------------------------------------------\r\n\r\n### Configure the GNU Radio environment\r\n\r\nFollow the steps in the FSK receiver example up to the point of receiving the baseband signal. In our case the signal (from an Audi A4 keyfob) is at 433.920MHz:\r\n\r\n![](Ask baseband.png \"Ask baseband.png\")\r\n\r\n### Signal visualization and identification\r\n\r\nOpen the file in Baudline (see FSK receiver for details of how to do this):\r\n\r\n![](Ask baudline.png \"Ask baudline.png\")\r\n\r\nYou can see at the beginning of the data burst (the preamble), the signal alternates between a large amplitude and zero down the screen (time axis). This clearly shows that the signal has been modulated using Amplitude Shift Keying (ASK), which is also known as On-Off Keying (OOK).\r\n\r\n### Filtering\r\n\r\nWe now want to focus in on the signal of interest and filter out any other signals present in the baseband we have recorded. Add a \"Low Pass Filter\" block between the \"Multiply\" block output and the \"WX GUI FFT Sink\" input.\r\n\r\n-   Set \"Cutoff Freq\" to 150e3 - this is the maximum frequency (of the modulated signal) that we want to display\r\n\r\n<!-- -->\r\n\r\n-   Set \"Transition Width\" to 50e3 - this is the bandwidth over which the filter will act i.e. the smaller the number the more aggressive the filter.\r\n\r\nRestart the flow-graph and you should see something like this:\r\n\r\n![](Grc filtered signal.png \"Grc filtered signal.png\")\r\n\r\n### Demodulating\r\n\r\nWe are making the assumption that based on the output we observed in Baudline, the modulation scheme is ASK (to be precise, \"2-ASK\" or \"Binary ASK\" where the amplitude is increased for a \"1\" and remains low for a \"0\"). Therefore, we need to add an ASK demodulator - \"AM Demod) Add a \"Quadrature Demod\" and set the \"Gain\" to be 1.\r\n\r\nAdd a \"File Sink\" and set its input type to be \"float\" (orange coloured) and set the filename to be something like \"4M\\_filtered\\_demod\"\r\n\r\nConnect the output of the \"Low Pass Filter\" to the input of the \"AM Demod\"\r\n\r\nSet the following \"AM Demod\" settings:\r\n\r\n-   \"Channel Rate\": 48e3\r\n\r\n<!-- -->\r\n\r\n-   \"Audio Decimation\": 1\r\n\r\nConnect the output of the \"AM Demod\" to the input of the \"File Sink\"\r\n\r\nIn \"File Source\" set \"Repeat to \"No\"\r\n\r\nYour flow-graph should now look like this:\r\n\r\n![](Ask flow demod.png \"Ask flow demod.png\")\r\n\r\nRun the flow-graph and it will produce a file that hopefully will contain demodulated data.\r\n\r\n### Visualising the data\r\n\r\nWe should now have a demodulated file that can be loaded into Baudline.\r\n\r\n**Note: Remember, if your \"4M\\_filtered\\_demod\" file is larger than 50Mb then you will need to split it into chunks again.**\r\n\r\nStart Baudline and load your demod file - use all the same parameters as before, but this time change \"Channels\" to 1 (it is no longer a complex baseband signal - it is a demodulated signal). Click \"Open\" and it should look something like this:\r\n\r\n![](Ask demod2.png \"Ask demod2.png\")\r\n\r\nEnsure that the separate \"Waveform\" window is open (main menu -\\> displays -\\> waveform)\r\n\r\n![](Ask demod1.png \"Ask demod1.png\")\r\n\r\nThese are the data bits represented by the original complex baseband signal we saw in Baudline. It also confirms that the data was modulated using 2-ASK.\r\n\r\n### Further filtering and clock recovery\r\n\r\nIf we look at the signal with respect to the scale, we can see that by choosing a peak, it's approximately 3.6 bits per millisecond, so it looks like 3600 Baud.\r\n\r\n![](Ask demod3.png \"Ask demod3.png\")\r\n\r\nOk, now we think we have the Baud rate, we can accurately add a new \"Low Pass Filter\" in between the \"AM Demod\" and the \"File Sink\". The settings should be as follows:\r\n\r\n-   Cutoff Freq = 4000 (roughly the Baud rate)\r\n\r\n<!-- -->\r\n\r\n-   Transition Width = 2000 (roughly half the Baud rate)\r\n\r\nAlso, you may have noticed that the flow-graph has been running very slowly since we started demodulating the data. Let's try and work out why:\r\n\r\nThe sample rate is currently 4,000,000 and the Baud rate is 3600, so if we divide 4,000,000 by 3600 we get the number of samples per symbol - 1111! That's why it's running slowly... we don't need anywhere near 1111 samples to represent each bit.\r\n\r\nIn the \"Low Pass Filter\" set \"FIR Type\" to \"Float-Float (Decimating)\" and set \"Decimation\" to 10. This will decimate the signal (reduce the sample rate) by a factor of 10\r\n\r\nNow re-run the flow-graph and load the resulting demodulated file into Baudline and the \"Waveform view\" should now look like this:\r\n\r\n**Note: When you load the file back into Baudline don't forget that the sample rate has been decimated by 100 and is now, therefore, 40,000 instead of 4,000,000**\r\n\r\n![](Ask demod filtered.png \"Ask demod filtered.png\")\r\n\r\nWe're not quite ready to recover the bits yet though, as the signal should be alternating about 0dBm (the centre line in the waveform view. It's actually down towards -90dBm, so it needs to be increased.\r\n\r\nAdd an \"Add Const\" block in between the second \"Low Pass Filter\" and the \"File Sink\" and set the \"Constant\" value to be 0.45 (this value was determined through trial-and-error), to increase the signal level. The output should now look like this:\r\n\r\n![](Ask demod filtered2.png \"Ask demod filtered2.png\")\r\n\r\n### Data recovery\r\n\r\nNow we are ready to recover the digital data. First we need to perform clock recovery - add a \"Clock Recovery MM\" block and set the following values:\r\n\r\n-   \"Gain Omega\": 0.01\r\n\r\n<!-- -->\r\n\r\n-   \"Mu\": 0\r\n\r\n<!-- -->\r\n\r\n-   \"Gain Mu\": 0.1\r\n\r\n<!-- -->\r\n\r\n-   \"Omega Relative Limit\": 0.01\r\n\r\nThe final value we need is \"Omega\" - this is the number of samples per symbol. We previously calculated this to be 1111.11 and so decimated the signal by a factor of 10 so \"Omega\" now needs to be set to 111.11 (1111.11 / 10).\r\n\r\nAdd a \"Binary Slicer\" to the output of the \"Clock Recovery MM\" block\r\n\r\nAdd a \"File Sink\" to the output of the \"Binary Slicer\" - you'll need to set the input type of the \"File Sink\" to \"Byte\" (pink coloured). Set the filename to be something like \"bitfile\"\r\n\r\nYour final flow-graph should look something like this:\r\n\r\n![](Ask full flowgraph.png \"Ask full flowgraph.png\")\r\n\r\nOpen up the \"bitfile\" file in a hex editor. Remember the preamble of \"0101010101...\"? You need to search for the preamble in the \"bitfile\", but if you look carefully, you can see that each byte in the file represents one bit i.e a \"0\" bit is represented by the byte \"00\" and a \"1\" bit is represented by the byte \"01\", so to search for the preamble you need to search for: \"0001000100010001\". The result of the search is shown below, the rest of the data follows the preamble:\r\n\r\n![](Ask hex output.png \"Ask hex output.png\")\r\n\r\nYou have now successfully retrieved the data from an ASK RF transmission!\r\n\r\n### Communicating with the receiver in real-time\r\n\r\nRather than using a file as a sink you can use a \"TCP Sink\" block, bind it to a socket and receive data from it via TCP\r\n\r\nTransmitting data\r\n=================\r\n\r\n\\<span style=\"color:red\"\\> **NOTE: Before transmitting any data, please fully read the [Legal considerations](https://wiki.pentest.ngs/index.php/RFTM#Legal_considerations) section** \\</span\\>\r\n\r\nRF shielding (Faraday cages)\r\n----------------------------\r\n\r\nIf you need to transmit signals on bands for which it would normally be illegal to do so e.g. Broadcast radio or 3G cellular then this can be performed within an RF-shielded environment. These come in all shapes and sizes, from small:\r\n\r\n![](Rf enclosure.png \"Rf enclosure.png\")\r\n\r\nto large:\r\n\r\n![](Screened room.jpg \"Screened room.jpg\")\r\n\r\nDirect connection using attenuators\r\n-----------------------------------\r\n\r\nAnother approach is to directly connect your transmitter to your receiver via a cable so that no radio waves are transmitted. However, in order to do this without damaging the receiver you need to use in-line attenuators (see below) to reduce the signal level, as would occur if it was transmitted via an antenna\r\n\r\n![](Attenuator.jpg \"Attenuator.jpg\")\r\n\r\nDeveloping a digital (FSK) transmitter step-by-step\r\n---------------------------------------------------\r\n\r\nIf you have captured some data from a target system using a receiver and you now wish to modify that data and re-transmit it (for example if you are developing an RF-based fuzzer) the following process can be followed. This transmitter is assumed to use FSK modulation (this example is actually a transmitter developed for the [io-homecontrol protocol](https://wiki.pentest.ngs/index.php/Io-homecontrol))\r\n\r\n### Data source\r\n\r\nThe assumption is that you start with a data file containing the binary data bytes you want to send\r\n\r\nCreate a new flow-graph and set the \"samp\\_rate\\_tx\" variable to 4e6\r\n\r\n![](Tx samp rate.png \"Tx samp rate.png\")\r\n\r\nAdd a \"File Source\" block and set the file to be your data file. Ensure that \"Repeat\" is set to \"No\" (unless you specifically want it to repeat)\r\n\r\n### Set the Baud rate\r\n\r\nHaving received the data, you should already know what the Baud rate should be set to. Add a new \"Variable\" block called \"baud\\_rate\" and set it to the correct value.\r\n\r\n![](Tx baud rate.png \"Tx baud rate.png\")\r\n\r\n### Modulation\r\n\r\nAdd a new \"Variable\" called \"sps\" (samples per symbol) and set it's value to be 10\r\n\r\n![](Tx sps.png \"Tx sps.png\")\r\n\r\nChange the default \"samp\\_rate\" \"Variable\" block to 384000 (10 x Baud rate, as we want 10 samples per symbol)\r\n\r\nAdd a \"GFSK Mod\" block, which will modulate the data using FSK. Configure the following settings:\r\n\r\n-   \"Samples/Symbol\": sps\r\n\r\n<!-- -->\r\n\r\n-   \"Sensitivity\": 1\r\n\r\n<!-- -->\r\n\r\n-   \"BT\": 1 (this will effectively remove the Gaussian filter and make it FSK rather than GFSK)\r\n\r\n![](Tx gfsk mod.png \"Tx gfsk mod.png\")\r\n\r\nYour flow-graph should now look like this:\r\n\r\n![](Tx source and mod.png \"Tx source and mod.png\")\r\n\r\n### Resampling\r\n\r\nWe now need to match the sample rate of the data with the transmitter (as it is the final sample rate of the transmitter that will actually determine the rate that the data is transmitted).\r\n\r\nAdd a \"Rational Resampler\" block with the following settings:\r\n\r\n-   \"Interpolation\": samp\\_rate\\_tx (the output sample rate)\r\n\r\n<!-- -->\r\n\r\n-   \"Decimation\": samp\\_rate (the input sample rate)\r\n\r\n![](Tx resampler.png \"Tx resampler.png\")\r\n\r\n### Adjust the signal level\r\n\r\nWe don't want to overload the input to the transmitter so we need to attenuate (reduce) the signal level.\r\n\r\nAdd a \"Multiply Const\" block and set \"Constant\" to be 0.8\r\n\r\n![](Tx const.png \"Tx const.png\")\r\n\r\n### Configure the transmitter\r\n\r\nWe are now ready to transmit the signal.\r\n\r\nAdd a \"Variable\" block with the name \"freq\" and value equal to the transmit frequency:\r\n\r\n![](Tx freq.png \"Tx freq.png\")\r\n\r\nAdd an \"osmocom Sink\" block with the following settings:\r\n\r\n-   \"Ch0: Frequency\": freq\r\n\r\n<!-- -->\r\n\r\n-   \"Ch0: RF Gain (dB)\": 30 (can be changed as required)\r\n\r\n<!-- -->\r\n\r\n-   \"Ch0: IF Gain (dB)\": 20 (can be changed as required)\r\n\r\n<!-- -->\r\n\r\n-   \"Ch0: BB Gain (dB)\": 20 (can be changed as required)\r\n\r\n![](Tx tx.png \"Tx tx.png\")\r\n\r\nThe complete transmitter flow-graph should now look like this:\r\n\r\n![](Iohome tx crop.png \"Iohome tx crop.png\")\r\n\r\n### Communicating with the transmitter in real-time\r\n\r\nRather than using a file as a source you can use a \"TCP Sink\" block, bind it to a socket and send it data via TCP\r\n\r\nSignals identification\r\n======================\r\n\r\nIn order to correctly demodulate a received signal you need to be able to identify it first. This section will provide some guidance around identifying common signals.\r\n\r\nThis [website](http://www.sigidwiki.com/wiki/Signal_Identification_Guide) is a good place to start.\r\n\r\nAmplitude Shift Keying (ASK)\r\n----------------------------\r\n\r\nThe below example is the most simple form of ASK, known as On-Off Keying (OOK):\r\n\r\n![]( ask_baudline.png \" ask_baudline.png\")\r\n\r\nFrequency Shift Keying (FSK)\r\n----------------------------\r\n\r\nThe below example is the most simple form of FSK, known as 2-FSK or Binary FSK:\r\n\r\n![](Fsk baudline.png \"Fsk baudline.png\")\r\n\r\nTODO - add more stuff here\r\n\r\nLegal considerations\r\n====================\r\n\r\nUnless you hold an [Amateur Radio license](http://licensing.ofcom.org.uk/radiocommunication-licences/amateur-radio/) or have had specific training about UK law with respect to the areas of the radio frequency spectrum and at what power levels you are allowed to transmit, it is highly recommended that you restrict yourself to only receiving. The amateur radio license is fairly easy to get and a few people in the company seem to have them. Try emailing DL-Tech and you may find someone local who is willing to lend you training materials or point you in the direction of a local club.\r\n\r\nA high level overview of UK law with respect to radio transmitters can be found [here](http://stakeholders.ofcom.org.uk/enforcement/spectrum-enforcement/law)\r\n\r\nExample flow-graphs and tutorials\r\n=================================\r\n\r\nSimple FM radio receiver\r\n------------------------\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}